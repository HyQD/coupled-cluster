import pytest
import numpy as np

from coupled_cluster.ccd.energies import compute_lagrangian_functional
from coupled_cluster import CCD

from coupled_cluster.mix import AlphaMixer, DIIS


def autogenerated_lagrangian(T2, L2, F, W, o, v, np):
    """
    Eq [A8] in Kvaal sans the reference energy
        E_ref = h^i_i + 0.5 u^{ij}_{ij}
            = f^{i}_{i} - 0.5 u^{ij}_{ij}
    """
    result = 0.25 * np.einsum(
        "lkdc,dclk->", L2, W[v, v, o, o], optimize=["einsum_path", (0, 1)]
    )
    result += 0.25 * np.einsum(
        "lkdc,lkdc->", T2, W[o, o, v, v], optimize=["einsum_path", (0, 1)]
    )
    result += np.einsum(
        "lkdc,kmec,dmel->",
        L2,
        T2,
        W[v, o, v, o],
        optimize=["einsum_path", (0, 1), (0, 1)],
    )
    result += 0.5 * np.einsum(
        "lkdc,kmdc,ml->",
        L2,
        T2,
        F[o, o],
        optimize=["einsum_path", (0, 1), (0, 1)],
    )
    result += 0.5 * np.einsum(
        "lkdc,lkec,de->",
        L2,
        T2,
        F[v, v],
        optimize=["einsum_path", (0, 1), (0, 1)],
    )
    result += 0.125 * np.einsum(
        "lkdc,mndc,mnlk->",
        L2,
        T2,
        W[o, o, o, o],
        optimize=["einsum_path", (0, 1), (0, 1)],
    )
    result += 0.125 * np.einsum(
        "lkdc,lkef,dcef->",
        L2,
        T2,
        W[v, v, v, v],
        optimize=["einsum_path", (0, 2), (0, 1)],
    )
    result += 0.5 * np.einsum(
        "lkdc,kndf,lmec,mnef->",
        L2,
        T2,
        T2,
        W[o, o, v, v],
        optimize=["einsum_path", (0, 1), (0, 1), (0, 1)],
    )
    result += -0.25 * np.einsum(
        "lkdc,lkdf,mnec,mnef->",
        L2,
        T2,
        T2,
        W[o, o, v, v],
        optimize=["einsum_path", (0, 1), (0, 1), (0, 1)],
    )
    result += -0.125 * np.einsum(
        "lkdc,kndc,lmef,mnef->",
        L2,
        T2,
        T2,
        W[o, o, v, v],
        optimize=["einsum_path", (0, 1), (0, 1), (0, 1)],
    )
    result += -0.125 * np.einsum(
        "lkdc,lmdc,knef,mnef->",
        L2,
        T2,
        T2,
        W[o, o, v, v],
        optimize=["einsum_path", (0, 1), (0, 1), (0, 1)],
    )
    result += 0.0625 * np.einsum(
        "lkdc,mndc,lkef,mnef->",
        L2,
        T2,
        T2,
        W[o, o, v, v],
        optimize=["einsum_path", (0, 1), (0, 1), (0, 1)],
    )

    return result


def test_lagrangian_functional_zanghellini(
    zanghellini_system, t_kwargs, l_kwargs
):
    ccd = CCD(zanghellini_system, verbose=True, mixer=AlphaMixer)
    ccd.iterate_t_amplitudes(**t_kwargs)
    ccd.iterate_l_amplitudes(**l_kwargs)

    h = zanghellini_system.h
    u = zanghellini_system.u
    o = zanghellini_system.o
    v = zanghellini_system.v
    f = zanghellini_system.construct_fock_matrix(h, u)

    t, l = ccd.t_2, ccd.l_2

    T2 = t.transpose(2, 3, 0, 1).copy()

    lagrangian_auto = autogenerated_lagrangian(T2, l, f, u, o, v, np)
    lagrangian = compute_lagrangian_functional(f, u, t, l, o, v, np)
    energy = ccd.compute_energy()
    man_energy = ccd.compute_one_body_expectation_value(
        zanghellini_system.h
    ) + 0.5 * ccd.compute_two_body_expectation_value(zanghellini_system.u)

    assert abs(lagrangian - lagrangian_auto) < 1e-8
    assert abs(man_energy - ccd.compute_reference_energy() - lagrangian) < 1e-8
    # Maybe the same?
    assert abs(lagrangian - (energy - ccd.compute_reference_energy())) < 1e-5


def test_lagrangian_functional(large_system_ccd):
    t, l, cs = large_system_ccd

    T2 = t.transpose(2, 3, 0, 1).copy()

    lagrangian_auto = autogenerated_lagrangian(
        T2, l, cs.f, cs.u, cs.o, cs.v, np
    )
    lagrangian = compute_lagrangian_functional(cs.f, cs.u, t, l, cs.o, cs.v, np)

    assert abs(lagrangian - lagrangian_auto) < 1e-8
